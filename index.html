<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="favicon.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>threejs</title>
  </head>
  <body>

    <canvas id="bg"></canvas>   

    <main>

      <header>
        <h1>Hello There!</h1>
        <p>ðŸš€ Welcome to Threejs Tutorial</p>
      </header>


      <blockquote>
        <p>Run GPU-powered games and other graphics-powered apps straight from the browser.</p>
      </blockquote>

      <section>
        <h2>Getting Started</h2>
        <p>
          three. js is a JavaScript-based WebGL engine that can run GPU-powered games and other graphics-powered apps straight from the browser.
        </p>

        <p>
          display anything with three. js, we need three things: scene, camera and renderer, so that we can render the scene with camera. const scene = new THREE. Scene(); const camera = new THREE.
        </p>

        <p>
          The first attribute is the field of view. FOV is the extent of the scene that is seen on the display at any given moment. The value is in degrees.

          The second one is the aspect ratio. You almost always want to use the width of the element divided by the height, or you'll get the same result as when you play old movies on a widescreen TV - the image looks squished.
          
          The next two attributes are the near and far clipping plane. What that means, is that objects further away from the camera than the value of far or closer than near won't be rendered. You don't have to worry about this now, but you may want to use other values in your apps to get better performance.
        </p>

      </section>

      <section class="light">
        <h2>Rendering the scene</h2>

        <p>
          create a loop that causes the renderer to draw the scene every time the screen is refreshed (on a typical screen this means 60 times per second). If you're new to writing games in the browser, you might say "why don't we just create a setInterval ?" The thing is - we could, but requestAnimationFrame has a number of advantages. Perhaps the most important one is that it pauses when the user navigates to another browser tab, hence not wasting their precious processing power and battery life.
        </p>

        <h2>Animating the cube</h2>

        <p>
          run every frame (normally 60 times per second), and give the cube a nice rotation animation. Basically, anything you want to move or change while the app is running has to go through the animate loop. You can of course call other functions from there, so that you don't end up with an animate function that's hundreds of lines.
        </p>

      </section>

      <blockquote>
        <p>Congratulations! You have now completed your first three.js application. It's simple, but you have to start somewhere.</p>
      </blockquote>

      <section class="left">
        <h2>Reference</h2>

        <h3>ArrayCamera</h3>
        <p>
          ArrayCamera can be used in order to efficiently render a scene with a predefined set of cameras. This is an important performance aspect for rendering VR scenes.
An instance of ArrayCamera always has an array of sub cameras. It's mandatory to define for each sub camera the viewport property which determines the part of the viewport that is rendered with this camera.
        </p>
        <h3>BoxGeometry</h3>
        <p>
          BoxGeometry is a geometry class for a rectangular cuboid with a given 'width', 'height', and 'depth'. On creation, the cuboid is centred on the origin, with each edge parallel to one of the axes.
        </p>
        <h3>DirectionalLight</h3>
        <p>
          A light that gets emitted in a specific direction. This light will behave as though it is infinitely far away and the rays produced from it are all parallel. The common use case for this is to simulate daylight; the sun is far enough away that its position can be considered to be infinite, and all light rays coming from it are parallel.
        </p>
        <h3>BoxHelper</h3>
        <p>
          Helper object to graphically show the world-axis-aligned bounding box around an object. The actual bounding box is handled with Box3, this is just a visual helper for debugging. It can be automatically resized with the BoxHelper.update method when the object it's created from is transformed. Note that the object must have a BufferGeometry for this to work, so it won't work with Sprites.
        </p>

      </section>

      <blockquote>
        <p>Thanks for watching!</p>
      </blockquote>


    </main>
    
    <script type="module" src="/main.js"></script>

  </body>
</html>